# -*- coding: utf-8 -*-
"""FC_HW4_new.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G21jSlW5ghJLgLtX-RzotcQnoX0NzKuH
"""

import math
import numpy as np
import scipy.stats as stats
from numpy.lib.function_base import average
import copy

St = 50
maxSt = 70
r = 0.1
q = 0
sigma = 0.4
T = 1/4
n = 100

dt = T/n
u = math.e**(sigma* dt**(1/2))
d = 1/u
p = (math.e**((r-q)*dt)-d)/(u-d)

S = np.zeros((n+1, n+1))
S[0,0] = St
a = 1
for j in range(1, n+1):
  for i in range(a):
    S[i,j] = round(S[i, j-1]*u,8)
    S[i+1,j] = round(S[i, j-1]*d,8)
  a += 1

for i in range(n+1):
  for j in range(n+1):
    S[i][j] = round(S[i][j],8)

S_=copy.deepcopy(S)
baseline=copy.deepcopy(S[0])

# for i in range(len(baseline)):
#   if baseline[i]<=maxSt:
#     baseline[i]=maxSt
#   else:
#     break
# print(baseline)
# print(S_)

for i in range(len(S_)):
  for j in range(i,len(S_[0]),1):
    if i==0:
      if j==0:
        S_[i][j]=round(max(S_[i][j],maxSt),8)
      else:
        # print(str(S_[i][j-1])+" "+str(S_[i][j])+" "+str(maxSt))
        S_[i][j]=round(max(S_[i][j-1],S_[i][j],maxSt),8)

    else:
      S_[i][j]=round(max(S_[i-1][j-1],S_[i][j-1],S_[i][j],maxSt),8)
# for i in range(len(S_)):
#   for j in range(i,len(S_[0]),1):
#     if i==0:
#       pass
#     else:
#       S_[i][j]=max(S_[i-1][j-1],S_[i][j-1])
# S_

S__back = np.zeros((n+1, n+1, n+1))
S__back[0][0][0] = maxSt
for i in range(len(S)):
  for j in range(i,len(S[0]),1):
    if i==0 and j==0:
      pass
    elif j!=0 and i==0:
      if S[i][j]>maxSt:
        S__back[i][j][0]=S[i][j]
      else:
        S__back[i][j][0]=maxSt
    else:
      index=0
      if S[i][j]>maxSt:
        S__back[i][j][0]=S[i][j]
        index=1
      else:
        S__back[i][j][0]=maxSt
      for k in range(len(S__back[i][j-1])):
        if S__back[i][j-1][k]>S[i][j] and S__back[i][j-1][k] not in S__back[i][j]:
          S__back[i][j][index]=S__back[i][j-1][k]
          index+=1
      for k in range(len(S__back[i-1][j-1])):
        if S__back[i-1][j-1][k]>S[i][j] and S__back[i-1][j-1][k] not in S__back[i][j]:
          S__back[i][j][index]=S__back[i-1][j-1][k]
          index+=1


for k in range(n+1):
  for i in range(n+1):
    for j in range(n+1):
      S__back[k][i][j] = round(S__back[k][i][j],8)

S_back = np.zeros((n+1, n+1, n+1))
S_back[0][0][0] = maxSt
for i in range(len(S)):
  for j in range(i,len(S[0]),1):
    if S_[i][j]==S[i][j]:
      S_back[i][j][0]=S_[i][j]
    else:
      index=0
      if S[i][j]<=maxSt:
        # print(str(S[i][j])+" "+str(S_[i][j]))
        S_back[i][j][index]=round(maxSt,8)
        index+=1
      for k in range(len(baseline)):
        if S[i][j]<=baseline[k]<=S_[i][j] and baseline[k]>maxSt:
          # print(str(S[i][j])+" "+str(S_[i][j]))
          # and S_[0][k] not in S_back[i][j]:
          S_back[i][j][index]=baseline[k]
          index+=1
        elif baseline[k]>S_[i][j]:
          break

for k in range(n+1):
  for i in range(n+1):
    for j in range(n+1):
      S_back[k][i][j] = round(S_back[k][i][j],8)

# S_back = np.zeros((2*n+1, n+1, n+1))
S_back = np.zeros((n+1, n+1, n+1))
S_back[0][0][0] = maxSt
for i in range(len(S)):
  for j in range(i,len(S[0]),1):
    if S_[i][j]==S[i][j]:
      S_back[i][j][0]=S_[i][j]
    else:
      index=0
      if S[i][j]<=maxSt:
        # print(str(S[i][j])+" "+str(S_[i][j]))
        S_back[i][j][index]=round(maxSt,8)
        index+=1
      for k in range(len(baseline)):
        if S[i][j]<=baseline[k]<=S_[i][j] and baseline[k]>maxSt:
          # print(str(S[i][j])+" "+str(S_[i][j]))
          # and S_[0][k] not in S_back[i][j]:
          S_back[i][j][index]=baseline[k]
          index+=1
        elif baseline[k]>S_[i][j]:
          break
for k in range(n+1):
  for i in range(n+1):
    for j in range(n+1):
      S_back[k][i][j] = round(S_back[k][i][j],8)
# for i in range(1,n+1):
#   S_back[0][0][i] = max(S[0][i],S[0][i-1])
#   #S_back[0][i][i] = max(S[i][i],maxSt)
#   S_back[0][i][i] = max(S[i][i],S_back[0][i-1][i-1])
# #print(S_back)
# print(S_back[4])


# print(S_back)

#last row payoff
payoff = np.zeros((n+1, n+1, n+1))
for i in range(n+1):
  for j in range(n,n+1,1):
    index=0
    for k in range(n+1):
      if S_back[i][j][k] != 0:
        # print(str(i)+" "+str(j))
        # print(S_back[i][j][k])
        payoff[i][j][index] = round(S_back[i][j][k] - S[i][j],8)
        index+=1
# print('S_back:')
# print(S_back[1])
# print('S:')
# print(S)
# print('payoff:')
# print(payoff)

#backward induction
discount = math.e**(-r*dt)
for j in range(n-1,-1,-1):
  for i in range(n):
    for k in range(n+1):
      if S_back[i][j][k]==0.:
        break
      else:
        # print(str(i)+" "+str(j)+" "+str(S_back[i][j][k])+" "+str(round(S_back[i][j][k]*u,9)))
        if S_back[i][j][k] in S_back[i][j+1]:
          # temp_index=S_back[i][j+1].index(S_back[i][j][k])
          temp_index= np.where(np.isclose(S_back[i][j+1], S_back[i][j][k]))
          # print(S_back[i][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i][j+1])
          # print(temp_index)
          # print("\n")
          payoff[i][j][k]+= p*payoff[i][j+1][temp_index]*discount
        elif round(S_back[i][j][k]*u,8) in S_back[i][j+1]:
          temp_index= np.where(np.isclose(S_back[i][j+1], round(S_back[i][j][k]*u,8)))
          # print(S_back[i][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i][j+1])
          # print(temp_index)
          # print("\n")
          payoff[i][j][k]+= p*payoff[i][j+1][temp_index]*discount
        else:
          payoff[i][j][k]+= p*payoff[i][j+1][0]*discount
        if S_back[i][j][k] in S_back[i+1][j+1]:
          temp_index= np.where(np.isclose(S_back[i+1][j+1], S_back[i][j][k]))
          # temp_index=S_back[i+1][j+1].index(S_back[i][j][k])
          # print(S_back[i+1][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i+1][j+1])
          # print(temp_index)
          # print("\n")
          # print(temp_index)
          payoff[i][j][k]+= (1-p)*payoff[i+1][j+1][temp_index]*discount

# for j in range(n,-1,-1):
#   for i in range(n+1):
#     for k in range(n+1):
#       for l in range(n+1):
#         a=0
#         if S_back[l][i][j+1] == S_back[k][i][j]:
#           a += p * payoff[l][i][j+1] * discount
#         elif round(S_back[l][i][j]*u,8) == S_back[k][i][j+1]:
#           a += p * payoff[l][i][j+1] * discount
#         if S_back[l][i][j] == S_back[k][i+1][j+1]:
#           a += (1-p) * S_back[k][i+1][j+1] * discount
#         payoff[k][i][j] = a
# payoff

value = payoff[0][0][0]
print('European option:', value)

#last row payoff
payoff_A = np.zeros((n+1, n+1, n+1))
for i in range(n+1):
  for j in range(n,n+1,1):
    index=0
    for k in range(n+1):
      if S_back[i][j][k] != 0:
        # print(str(i)+" "+str(j))
        # print(S_back[i][j][k])
        payoff_A[i][j][index] = round(S_back[i][j][k] - S[i][j],8)
        index+=1
# print('S_back:')
# print(S_back[1])
# print('S:')
# print(S)
# print('payoff:')
# print(payoff_A)

#backward induction
discount = math.e**(-r*dt)
for j in range(n-1,-1,-1):
  for i in range(n):
    for k in range(n+1):
      if S_back[i][j][k]==0.:
        break
      else:
        # print(str(i)+" "+str(j)+" "+str(S_back[i][j][k])+" "+str(round(S_back[i][j][k]*u,9)))
        if S_back[i][j][k] in S_back[i][j+1]:
          # temp_index=S_back[i][j+1].index(S_back[i][j][k])
          temp_index= np.where(np.isclose(S_back[i][j+1], S_back[i][j][k]))
          # print(S_back[i][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i][j+1])
          # print(temp_index)
          # print("\n")
          payoff_A[i][j][k]+= p*payoff_A[i][j+1][temp_index]*discount
        elif round(S_back[i][j][k]*u,8) in S_back[i][j+1]:
          temp_index= np.where(np.isclose(S_back[i][j+1], round(S_back[i][j][k]*u,8)))
          # print(S_back[i][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i][j+1])
          # print(temp_index)
          # print("\n")
          payoff_A[i][j][k]+= p*payoff_A[i][j+1][temp_index]*discount
        else:
          payoff_A[i][j][k]+= p*payoff_A[i][j+1][0]*discount
        if S_back[i][j][k] in S_back[i+1][j+1]:
          temp_index= np.where(np.isclose(S_back[i+1][j+1], S_back[i][j][k]))
          # temp_index=S_back[i+1][j+1].index(S_back[i][j][k])
          # print(S_back[i+1][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i+1][j+1])
          # print(temp_index)
          # print("\n")
          # print(temp_index)
          payoff_A[i][j][k]+= (1-p)*payoff_A[i+1][j+1][temp_index]*discount
        payoff_A[i][j][k]=max(payoff_A[i][j][k],round(S_back[i][j][k]-S[i][j],8))
          # print(S[i][j])

# for j in range(n,-1,-1):
#   for i in range(n+1):
#     for k in range(n+1):
#       for l in range(n+1):
#         a=0
#         if S_back[l][i][j+1] == S_back[k][i][j]:
#           a += p * payoff[l][i][j+1] * discount
#         elif round(S_back[l][i][j]*u,8) == S_back[k][i][j+1]:
#           a += p * payoff[l][i][j+1] * discount
#         if S_back[l][i][j] == S_back[k][i+1][j+1]:
#           a += (1-p) * S_back[k][i+1][j+1] * discount
#         payoff[k][i][j] = a
# payoff

value = payoff_A[0][0][0]
print('American option:', value)

value = payoff[0][0][0]
print('European option:', value)

value = payoff_A[0][0][0]
print('American option:', value)

St = 50
maxSt = 50
r = 0.1
q = 0
sigma = 0.4
T = 1/4
n = 100

payoff=[]
payoff20=[]
for count in range(20):
  for Simulation in range(10000):
    S_dt=[]
    mu = math.log(St)+(r-q-(sigma**2)/2)*(T/n)
    sd = ((T/n)**(1/2))*sigma
    #print(mu)
    samplelog = np.random.normal(mu, sd, 1)
    for i in range(len(samplelog)):
      S_dt.append(samplelog[i])


    for i in range(n-1):
      mu_ = S_dt[i]+(r-q-(sigma**2)/2)*(T/n)
      samplelog_ = np.random.normal(mu_, sd, 1)
      for i in range(len(samplelog_)):
        S_dt.append(samplelog_[i])

    for i in range(len(S_dt)):
      S_dt[i]=math.e**(S_dt[i])
    #print(S_dt)
    K=max(S_dt)
    K=max(K,maxSt)
    #print(K)
    #print(S_dt[-1])


    if S_dt[-1] < K:
      payoff.append(K-S_dt[-1])
    else:
      payoff.append(0)

    #print(payoff)
  payoff20.append(average(payoff)*math.e**(-r*T))
print(payoff20)

mean = average(payoff20)
sd = np.std(payoff20)
print('95% confidence interval: ['+str(mean-2*sd)+', '+str(mean+2*sd)+']')

# S_back = np.zeros((2*n+1, n+1, n+1))
S_back = np.zeros((n+1, n+1, n+1))
S_back[0][0][0] = maxSt
for i in range(len(S)):
  for j in range(i,len(S[0]),1):
    if S_[i][j]==S[i][j]:
      S_back[i][j][0]=S_[i][j]
    else:
      index=0
      if S[i][j]<=maxSt:
        # print(str(S[i][j])+" "+str(S_[i][j]))
        S_back[i][j][index]=round(maxSt,8)
        index+=1
      for k in range(len(baseline)):
        if S[i][j]<=baseline[k]<=S_[i][j] and baseline[k]>maxSt:
          # print(str(S[i][j])+" "+str(S_[i][j]))
          # and S_[0][k] not in S_back[i][j]:
          S_back[i][j][index]=baseline[k]
          index+=1
        elif baseline[k]>S_[i][j]:
          break
for k in range(n+1):
  for i in range(n+1):
    for j in range(n+1):
      S_back[k][i][j] = round(S_back[k][i][j],8)
# for i in range(1,n+1):
#   S_back[0][0][i] = max(S[0][i],S[0][i-1])
#   #S_back[0][i][i] = max(S[i][i],maxSt)
#   S_back[0][i][i] = max(S[i][i],S_back[0][i-1][i-1])
# #print(S_back)
# print(S_back[4])


# print(S_back)

#最後一排payoff
payoff = np.zeros((n+1, n+1, n+1))
for i in range(n+1):
  for j in range(n,n+1,1):
    index=0
    for k in range(n+1):
      if S_back[i][j][k] != 0:
        # print(str(i)+" "+str(j))
        # print(S_back[i][j][k])
        payoff[i][j][index] = round(S_back[i][j][k] - S[i][j],8)
        index+=1

#backward induction
discount = math.e**(-r*dt)
for j in range(n-1,-1,-1):
  for i in range(n):
    for k in range(n+1):
      if S_back[i][j][k]==0.:
        break
      else:
        # print(str(i)+" "+str(j)+" "+str(S_back[i][j][k])+" "+str(round(S_back[i][j][k]*u,9)))
        if S_back[i][j][k] in S_back[i][j+1]:
          # temp_index=S_back[i][j+1].index(S_back[i][j][k])
          temp_index= np.where(np.isclose(S_back[i][j+1], S_back[i][j][k]))
          # print(S_back[i][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i][j+1])
          # print(temp_index)
          # print("\n")
          payoff[i][j][k]+= p*payoff[i][j+1][temp_index]*discount
        elif round(S_back[i][j][k]*u,8) in S_back[i][j+1]:
          temp_index= np.where(np.isclose(S_back[i][j+1], round(S_back[i][j][k]*u,8)))
          # print(S_back[i][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i][j+1])
          # print(temp_index)
          # print("\n")
          payoff[i][j][k]+= p*payoff[i][j+1][temp_index]*discount
        else:
          payoff[i][j][k]+= p*payoff[i][j+1][0]*discount
        if S_back[i][j][k] in S_back[i+1][j+1]:
          temp_index= np.where(np.isclose(S_back[i+1][j+1], S_back[i][j][k]))
          # temp_index=S_back[i+1][j+1].index(S_back[i][j][k])
          # print(S_back[i+1][j+1])
          # print(S_back[i][j][k])
          # print(payoff[i+1][j+1])
          # print(temp_index)
          # print("\n")
          # print(temp_index)
          payoff[i][j][k]+= (1-p)*payoff[i+1][j+1][temp_index]*discount

value = payoff[0][0][0]
print('European option:', value)